# CTF-ASAS v2.5 语义分析与自动化解题计划 (Logic Reasoning)

## 1. 目标

使 Agent 能够理解 Ghidra 导出的 C 伪代码，识别核心加密逻辑，并自动生成 Python 求解脚本 (Solver)。

## 2. 核心挑战

- **Token 限制**: 全量伪代码可能过长。
- **语义理解**: 需要准确识别异或循环、位移操作及特定的加密常量（如 TEA 的 `0x9e3779b9`）。
- **脚本执行**: 需要一个安全的沙箱环境来运行 Agent 生成的 Python 代码。

## 3. 实施步骤

### 3.1 增加 "逻辑理解" 节点 (Node: `analyze_logic`)

- **职责**: 接收 `reverse_ghidra_decompile` 的结果，使用专门的 Prompt 进行语义提炼。
- **Prompt 内容**: "你是顶级逆向专家。请分析以下 C 伪代码：1. 识别 Flag 处理流程；2. 提取加密常量；3. 识别算法类型；4. 输出算法的数学逻辑。"

### 3.2 增加 "Solver 生成" 节点 (Node: `generate_solver`)

- **职责**: 基于 `analyze_logic` 的输出，编写 Python 求解脚本。
- **输出**: 完善的 `.py` 脚本内容。

### 3.3 增加 "脚本执行" 工具 (Tool: `misc_run_python`)

- **职责**: 在本地或隔离容器中执行 Python 脚本，并返回 stdout。

## 4. 验证场景

- 题目：一个简单的逆向题，逻辑为 `for (i=0; i<len; i++) flag[i] ^= 0x66;`。
- 预期流程：反编译 -> 识别 XOR 0x66 -> 生成 `print("".join(chr(c ^ 0x66) for c in data))` -> 运行并拿到 Flag。

---
Implemented Plan in Chinese. Syncing with User Guide next.
