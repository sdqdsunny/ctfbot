# Superpowers 技能库详解

本文档详细介绍 `skills/` 目录下所有技能的定义、使用方法和适用场景。

---

## 目录

1. [brainstorming - 设计讨论](#1-brainstorming---设计讨论)
2. [writing-plans - 编写计划](#2-writing-plans---编写计划)
3. [executing-plans - 执行计划](#3-executing-plans---执行计划)
4. [subagent-driven-development - 子代理驱动开发](#4-subagent-driven-development---子代理驱动开发)
5. [test-driven-development - 测试驱动开发](#5-test-driven-development---测试驱动开发)
6. [systematic-debugging - 系统化调试](#6-systematic-debugging---系统化调试)
7. [verification-before-completion - 完成前验证](#7-verification-before-completion---完成前验证)
8. [using-git-worktrees - 使用 Git Worktrees](#8-using-git-worktrees---使用-git-worktrees)
9. [finishing-a-development-branch - 完成开发分支](#9-finishing-a-development-branch---完成开发分支)
10. [dispatching-parallel-agents - 并行调度子代理](#10-dispatching-parallel-agents---并行调度子代理)
11. [requesting-code-review - 请求代码审查](#11-requesting-code-review---请求代码审查)
12. [receiving-code-review - 接收代码审查](#12-receiving-code-review---接收代码审查)
13. [using-superpowers - 使用技能系统](#13-using-superpowers---使用技能系统)
14. [writing-skills - 编写技能](#14-writing-skills---编写技能)

---

## 1. brainstorming - 设计讨论

### 核心定义
通过自然对话的方式，将模糊的想法转化为完整的设计规格。

### 适用场景
- **必须使用**：任何创意性工作之前，包括创建功能、构建组件、添加功能或修改行为。
- 在写任何代码之前，探索用户意图、需求和设计方案。

### 工作流程

1.  **理解想法**
    - 先检查当前项目状态（文件、文档、最近提交）
    - 每次只问一个问题，逐步细化
    - 优先使用多选题，开放式问题也可
    - 聚焦于：目的、约束条件、成功标准

2.  **探索方案**
    - 提出 2-3 个不同方案及其权衡
    - 以对话方式呈现，给出推荐选项并说明理由

3.  **呈现设计**
    - 分段呈现设计（每段 200-300 字）
    - 每段后确认是否正确
    - 涵盖：架构、组件、数据流、错误处理、测试

4.  **后续行动**
    - 将验证通过的设计写入 `docs/plans/YYYY-MM-DD-<topic>-design.md`
    - 询问用户是否准备好进入实施阶段

### 核心原则
- **一次一个问题**：不要用大量问题压垮用户
- **YAGNI 原则**：从设计中移除所有不必要的功能
- **逐步验证**：分段呈现设计，每段确认

---

## 2. writing-plans - 编写计划

### 核心定义
将规格或需求转化为详尽的实施计划，假设执行者对代码库毫无上下文。

### 适用场景
- 当你有规格或需求，准备进行多步骤任务时使用。
- **在动手写代码之前**使用。

### 任务粒度
每个步骤应是一个原子操作（2-5 分钟完成）：
- "写失败的测试" - 一个步骤
- "运行测试确认失败" - 一个步骤
- "实现最小代码使测试通过" - 一个步骤
- "运行测试确认通过" - 一个步骤
- "提交" - 一个步骤

### 计划文档结构

```markdown
# [功能名称] Implementation Plan

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans

**Goal:** [一句话描述目标]
**Architecture:** [2-3 句话介绍方法]
**Tech Stack:** [关键技术/库]

---

### Task N: [组件名称]

**Files:**
- Create: `exact/path/to/file.py`
- Modify: `exact/path/to/existing.py:123-145`
- Test: `tests/exact/path/to/test.py`

**Step 1: 写失败的测试**
[代码]

**Step 2: 运行测试验证失败**
Run: `pytest tests/path/test.py::test_name -v`
Expected: FAIL with "function not defined"

**Step 3: 写最小实现**
[代码]

**Step 4: 运行测试验证通过**
...

**Step 5: 提交**
...
```

### 输出路径
计划保存至：`docs/plans/YYYY-MM-DD-<feature-name>.md`

---

## 3. executing-plans - 执行计划

### 核心定义
加载计划，批量执行任务，在批次之间向用户汇报进度并等待反馈。

### 适用场景
- 当你已有书面实施计划，需要在 **独立会话** 中执行时使用。

### 工作流程

1.  **加载与审查计划**：读取计划文件，审查并提出疑问。
2.  **批量执行**：默认每批 3 个任务。
    - 标记为 `in_progress`
    - 按步骤精确执行
    - 运行验证命令
    - 标记为 `completed`
3.  **汇报**："完成批次，等待反馈。"
4.  **继续**：根据反馈调整，执行下一批次。
5.  **收尾**：所有任务完成后，使用 `finishing-a-development-branch` 技能。

### 何时停止并请求帮助
- 遇到阻塞（缺少依赖、测试失败、指令不清）
- 计划有重大缺漏
- 无法理解某条指令
- 验证反复失败

**核心原则**：宁可停下来问，也不要猜测。

---

## 4. subagent-driven-development - 子代理驱动开发

### 核心定义
通过为每个任务派遣独立的子代理来执行计划，并在每个任务后进行两阶段审查。

### 适用场景
- 当你有实施计划，且任务之间相互独立。
- 希望在 **当前会话** 中快速迭代执行。

### 与 `executing-plans` 的区别
| 特点     | subagent-driven-development  | executing-plans        |
| -------- | ---------------------------- | ---------------------- |
| 会话     | 当前会话                     | 独立会话               |
| 上下文   | 每个任务独立子代理（无污染） | 共享上下文（可能累积） |
| 审查     | 两阶段自动审查               | 批次间人工检查点       |
| 迭代速度 | 更快                         | 依赖人工反馈           |

### 工作流程

1.  **提取任务**：读取计划，提取所有任务及其完整文本。
2.  **派遣实现子代理**：将任务文本和上下文发给子代理。
3.  **子代理实现**：实现、测试、提交、自我审查。
4.  **派遣规格审查子代理**：确认代码是否符合规格。
5.  **派遣代码质量审查子代理**：评估代码质量。
6.  **标记完成**：两阶段审查通过后标记任务完成。
7.  **循环至所有任务完成**。
8.  **最终代码审查**：派遣最终审查子代理。
9.  **使用 `finishing-a-development-branch` 收尾**。

### 核心原则
- **从不跳过审查**（无论是规格审查还是代码质量审查）。
- **审查发现问题**：实现子代理修复 → 重新审查 → 直到通过。
- **规格审查必须在代码质量审查之前**。

---

## 5. test-driven-development - 测试驱动开发

### 核心定义
**先写测试，看它失败，再写最小代码使其通过。**

### 铁律
```
没有失败的测试就没有生产代码。
```
先写了代码？**删除它，重新开始。**

### 适用场景
- **始终适用于**：新功能、Bug 修复、重构、行为变更。
- **例外（需用户许可）**：一次性原型、生成代码、配置文件。

### RED-GREEN-REFACTOR 循环

| 阶段         | 行动                   | 验证                         |
| ------------ | ---------------------- | ---------------------------- |
| **RED**      | 写一个失败的测试       | 运行测试，确认失败（非报错） |
| **GREEN**    | 写最小代码使测试通过   | 运行测试，确认通过           |
| **REFACTOR** | 重构代码，保持测试绿色 | 运行测试，确认仍通过         |

### 常见借口与现实

| 借口                    | 现实                                   |
| ----------------------- | -------------------------------------- |
| "太简单不用测"          | 简单代码也会出错。测试只需 30 秒。     |
| "我之后再测"            | 之后写的测试立刻通过，什么都证明不了。 |
| "手动测过了"            | 手动测试无法记录、无法复现、容易遗漏。 |
| "删掉 X 小时工作太浪费" | 沉没成本谬误。不可信的代码就是技术债。 |

### 核心原则
**如果你没见过测试失败，你就不知道它测的是不是对的。**

---

## 6. systematic-debugging - 系统化调试

### 核心定义
**在尝试任何修复之前，必须先找到根本原因。**

### 铁律
```
没有根因调查就没有修复方案。
```

### 适用场景
- 任何技术问题：测试失败、生产 Bug、意外行为、性能问题、构建失败、集成问题。
- **尤其**在时间紧迫时（紧急情况最容易诱发瞎猜）。

### 四阶段流程

| 阶段              | 关键活动                                           | 成功标准               |
| ----------------- | -------------------------------------------------- | ---------------------- |
| **1. 根因调查**   | 仔细阅读错误信息、稳定复现、检查最近变更、收集证据 | 理解问题的 What 和 Why |
| **2. 模式分析**   | 找到相似的正常代码、对比差异、理解依赖             | 识别差异点             |
| **3. 假设与测试** | 提出单一假设、做最小变更验证                       | 假设得到验证或否定     |
| **4. 实施**       | 创建失败测试用例、实施单一修复、验证               | Bug 解决，测试通过     |

### 红旗思维（立即停止）
- "先快速修一下，之后再调查"
- "试试改 X 看看有没有用"
- "已经尝试了多个修复但都没用"（如果 ≥3 次修复失败，应质疑架构）

### 核心原则
**症状修复是失败。必须找到根本原因。**

---

## 7. verification-before-completion - 完成前验证

### 核心定义
**声称完成之前，必须有新鲜的验证证据。**

### 铁律
```
没有刚执行的验证输出就没有完成声明。
```

### 适用场景
- 在声称任何成功/完成/通过之前。
- 在提交、创建 PR、标记任务完成之前。
- 在移动到下一个任务之前。

### 验证门函数
```
在声称任何状态之前：
1. 识别：什么命令能证明这个声称？
2. 执行：运行完整命令（新鲜的，完整的）
3. 阅读：完整输出、检查退出码、计数失败数
4. 验证：输出是否确认声称？
   - 否：陈述实际状态及证据
   - 是：陈述声称并附上证据
5. 然后才能发表声称
```

### 禁止用语
- "应该可以了"
- "应该通过了"
- "看起来没问题"
- "完美！" / "搞定！"（在验证之前）

### 核心原则
**证据优先。运行命令、阅读输出、然后声称结果。不可商量。**

---

## 8. using-git-worktrees - 使用 Git Worktrees

### 核心定义
创建隔离的 Git Worktree 工作区，允许同时在多个分支上工作。

### 适用场景
- 开始需要与当前工作区隔离的功能开发。
- 执行实施计划之前。

### 目录选择优先级
1.  检查现有目录（`.worktrees` 或 `worktrees`）
2.  检查 `CLAUDE.md` 中的偏好设置
3.  询问用户（项目本地 vs 全局位置）

### 安全验证
对于项目本地目录，**必须验证目录已被 `.gitignore` 忽略**：
```bash
git check-ignore -q .worktrees 2>/dev/null
```
如果未被忽略，则添加到 `.gitignore` 并提交。

### 工作流程
1.  检测项目名称
2.  创建 Worktree（指定分支）
3.  运行项目设置（`npm install`, `cargo build` 等）
4.  验证测试基线（确保测试通过）
5.  报告就绪状态

### 核心原则
**系统化目录选择 + 安全验证 = 可靠隔离。**

---

## 9. finishing-a-development-branch - 完成开发分支

### 核心定义
验证测试通过 → 呈现选项 → 执行用户选择 → 清理工作区。

### 适用场景
- 实施完成、所有测试通过。
- 需要决定如何集成工作成果。

### 呈现的四个选项
1.  **本地合并**：合并回基础分支
2.  **推送并创建 PR**
3.  **保持现状**（稍后处理）
4.  **丢弃工作**（需输入 "discard" 确认）

### 工作流程
1.  **验证测试**：测试失败则停止。
2.  **确定基础分支**（main/master）。
3.  **呈现四个选项**。
4.  **执行用户选择**。
5.  **清理 Worktree**（选项 1、4 时清理）。

### 核心原则
**测试失败不得继续。丢弃工作需明确确认。**

---

## 10. dispatching-parallel-agents - 并行调度子代理

### 核心定义
当面对多个独立问题（不同测试文件、不同子系统），并行派遣多个子代理同时处理。

### 适用场景
- 3+ 个测试文件因不同根因失败
- 多个子系统独立损坏
- 各问题可独立理解，无共享状态

### 不适用场景
- 失败相互关联（修复一个可能修复其他）
- 需要理解完整系统状态
- 代理间会相互干扰

### 工作流程
1.  **识别独立领域**：按问题源分组（工具批准流、批处理行为、中止功能等）。
2.  **创建聚焦任务**：每个代理获得明确范围、清晰目标、约束条件、期望输出。
3.  **并行派遣**。
4.  **审查与整合**：阅读摘要、验证无冲突、运行完整测试套件。

### Agent Prompt 结构示例
```markdown
修复 src/agents/agent-tool-abort.test.ts 的 3 个失败测试：
1. "should abort tool with partial output capture" - 期望消息包含 'interrupted at'
2. ...

这些是时序/竞态条件问题。你的任务：
1. 阅读测试文件，理解每个测试验证什么
2. 识别根因 - 时序问题还是实际 Bug？
3. 修复...
不要只增加超时时间 - 找到真正问题。

返回：发现了什么、修复了什么的摘要。
```

### 核心原则
**每个独立问题域一个代理。让它们并行工作。**

---

## 11. requesting-code-review - 请求代码审查

### 核心定义
派遣代码审查子代理，在问题级联之前捕获。

### 适用场景
- **必须**：子代理驱动开发中每个任务之后、完成主要功能后、合并到 main 之前。
- **可选**：卡住时（新视角）、重构前（基线检查）、修复复杂 Bug 后。

### 工作流程
1.  **获取 Git SHA**：
    ```bash
    BASE_SHA=$(git rev-parse HEAD~1)
    HEAD_SHA=$(git rev-parse HEAD)
    ```
2.  **派遣代码审查子代理**（使用模板填充占位符）。
3.  **处理反馈**：
    - Critical → 立即修复
    - Important → 继续前修复
    - Minor → 稍后处理

### 核心原则
**早审查，勤审查。**

---

## 12. receiving-code-review - 接收代码审查

### 核心定义
代码审查需要技术评估，而非情感表演。

### 适用场景
- 收到代码审查反馈时。
- 在实施建议之前。
- 反馈不清晰或技术上可疑时。

### 禁止回应
```
❌ "你说得太对了！"
❌ "好观点！"
❌ "让我马上实现"（未验证前）
```

### 正确回应模式
```
1. 阅读：完整反馈，不做反应
2. 理解：用自己的话复述需求（或询问）
3. 验证：对照代码库现实检查
4. 评估：对这个代码库技术上是否合理？
5. 回应：技术确认或有理有据的反驳
6. 实施：一次一项，逐个测试
```

### 何时反驳
- 建议破坏现有功能
- 审查者缺乏完整上下文
- 违反 YAGNI（未使用的功能）
- 对当前技术栈技术上不正确
- 与架构决策冲突

### 核心原则
**验证后再实施。提问后再假设。技术正确优于社交舒适。**

---

## 13. using-superpowers - 使用技能系统

### 核心定义
开始任何对话时使用，确立如何查找和使用技能。

### 铁律
```
如果你认为有 1% 的可能某个技能适用，你必须调用它。
这不是建议，这是强制。
```

### 使用流程
1.  **用户消息到达**
2.  **判断**：是否有任何技能可能适用？
3.  **即使只有 1% 可能性**：调用 Skill 工具
4.  **宣布**："我正在使用 [技能名] 来 [目的]"
5.  **如有检查清单**：为每项创建 TodoWrite
6.  **精确遵循技能指令**

### 红旗思维（停止并检查技能）
| 想法                     | 现实                         |
| ------------------------ | ---------------------------- |
| "这只是个简单问题"       | 问题也是任务。检查技能。     |
| "我需要先了解更多上下文" | 技能检查在询问之前。         |
| "让我先探索代码库"       | 技能告诉你如何探索。先检查。 |
| "这不需要正式技能"       | 如果技能存在，就使用它。     |
| "我记得这个技能"         | 技能会演进。阅读当前版本。   |

### 技能类型
- **刚性**（TDD、调试）：精确遵循，不要放弃纪律。
- **灵活**（模式）：将原则适应上下文。

---

## 14. writing-skills - 编写技能

### 核心定义
**编写技能就是将测试驱动开发应用于流程文档。**

### 适用场景
- 创建新技能
- 编辑现有技能
- 部署前验证技能有效

### TDD 映射

| TDD 概念             | 技能创建对应               |
| -------------------- | -------------------------- |
| **测试用例**         | 压力场景（子代理）         |
| **生产代码**         | 技能文档（SKILL.md）       |
| **测试失败 (RED)**   | 没有技能时代理违规（基线） |
| **测试通过 (GREEN)** | 有技能时代理遵守           |
| **重构**             | 堵住漏洞，保持遵守         |

### 何时创建技能
- 技术对你来说不是直觉显而易见的
- 你会在不同项目中再次引用
- 模式广泛适用（非项目特定）

### 不创建技能
- 一次性解决方案
- 标准实践（其他地方有良好文档）
- 项目特定约定（放入 CLAUDE.md）

### SKILL.md 结构
```markdown
---
name: skill-name-with-hyphens
description: Use when [触发条件和症状]
---

# Skill Name

## Overview
这是什么？1-2 句核心原则。

## When to Use
(如决策不明显则用小流程图)
症状和用例列表
何时不使用

## Core Pattern
代码前后对比

## Quick Reference
扫描常见操作的表格或列表

## Common Mistakes
问题 + 修复

## Real-World Impact (可选)
具体结果
```

### 核心原则
**没有失败的测试就没有技能。与代码的 TDD 原则完全相同。**

---

## 技能使用总结

| 技能                           | 何时使用                 | 核心价值                |
| ------------------------------ | ------------------------ | ----------------------- |
| brainstorming                  | 任何创意工作开始前       | 需求理清、设计验证      |
| writing-plans                  | 有规格后，写代码前       | 清晰的执行路线图        |
| executing-plans                | 有计划，在独立会话中执行 | 批量执行 + 人工检查点   |
| subagent-driven-development    | 有计划，当前会话快速迭代 | 独立子代理 + 两阶段审查 |
| test-driven-development        | 实现任何功能或修复 Bug   | 质量保证、回归预防      |
| systematic-debugging           | 遇到任何 Bug 或意外行为  | 根因定位、避免瞎猜      |
| verification-before-completion | 声称完成之前             | 证据驱动、诚实汇报      |
| using-git-worktrees            | 需要隔离开发环境时       | 并行开发、干净基线      |
| finishing-a-development-branch | 实施完成，测试通过       | 有序收尾、清理工作区    |
| dispatching-parallel-agents    | 多个独立问题需同时处理   | 并行效率、节省时间      |
| requesting-code-review         | 完成任务后、合并前       | 质量门禁、问题发现      |
| receiving-code-review          | 收到审查反馈后           | 技术评估、理性处理      |
| using-superpowers              | 任何对话开始时           | 技能系统入口            |
| writing-skills                 | 创建/编辑技能时          | 技能质量、可测试性      |
